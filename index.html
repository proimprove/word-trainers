<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–¢—Ä–µ–Ω–∞–∂—ë—Ä ¬´–û–ø–∏—Å–∞–Ω–∏–µ —Å–ª–æ–≤–∞¬ª + Gemini AI</title>
    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles to prevent layout shifts and improve mobile UX */
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f3f4f6;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior-y: none; /* Prevent pull-to-refresh on mobile */
        }
        
        .screen {
            display: none;
            min-height: 100vh;
            flex-direction: column;
        }

        .screen.active {
            display: flex;
        }

        /* Smooth transitions */
        .btn {
            transition: all 0.2s ease;
        }
        .btn:active {
            transform: scale(0.96);
        }

        /* Timer animation */
        .timer-bar-container {
            width: 100%;
            height: 8px;
            background-color: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .timer-bar {
            height: 100%;
            background-color: #3b82f6;
            width: 100%;
            transition: width 1s linear;
        }

        .timer-bar.urgent {
            background-color: #ef4444;
        }

        /* Card styles */
        .card {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        /* Toggle Switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #3b82f6;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #3b82f6;
        }

        /* Flash effect for word change */
        @keyframes flash {
            0% { opacity: 0; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 1; transform: scale(1); }
        }
        .word-anim {
            animation: flash 0.3s ease-out forwards;
        }
        
        /* Loading Spinner */
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="text-gray-800">

    <!-- AUDIO CONTEXT HIDDEN ELEMENT -->
    <div id="audio-root"></div>

    <!-- ================= SCREENS ================= -->

    <!-- 1. RULES & SETTINGS SCREEN -->
    <div id="screen-rules" class="screen active p-4 max-w-md mx-auto">
        <header class="mb-4 text-center">
            <h1 class="text-2xl font-bold text-indigo-600 flex justify-center items-center gap-2">
                –û–ø–∏—Å–∞–Ω–∏–µ —Å–ª–æ–≤–∞
                <span class="text-xs bg-indigo-100 text-indigo-600 px-2 py-1 rounded-full">AI‚ú®</span>
            </h1>
            <p class="text-sm text-gray-500" id="welcome-text">–¢—Ä–µ–Ω–∞–∂—ë—Ä —É—Å—Ç–Ω–æ–π —Ä–µ—á–∏</p>
        </header>

        <!-- Rules Card -->
        <div class="card p-5 mb-6 border-l-4 border-indigo-500">
            <h2 class="font-bold text-lg mb-3">üìù –ü—Ä–∞–≤–∏–ª–∞</h2>
            <ul class="space-y-2 text-sm text-gray-700">
                <li class="flex items-start">
                    <span class="mr-2 text-green-500">‚úî</span>
                    <span>–ì–æ–≤–æ—Ä–∏ —Ç–æ–ª—å–∫–æ <b>¬´–ö–ê–ö–û–ô?¬ª</b> (–ø—Ä–∏–∑–Ω–∞–∫–∏, –∫–∞—á–µ—Å—Ç–≤–∞).</span>
                </li>
                <li class="flex items-start">
                    <span class="mr-2 text-red-500">‚úñ</span>
                    <span>–ù–µ –Ω–∞–∑—ã–≤–∞–π —Å–∞–º –ø—Ä–µ–¥–º–µ—Ç –∏ –Ω–µ –≥–æ–≤–æ—Ä–∏ ¬´—á—Ç–æ –¥–µ–ª–∞–µ—Ç¬ª.</span>
                </li>
                <li class="flex items-start">
                    <span class="mr-2">üí°</span>
                    <span>–ó–∞—Å—Ç—Ä—è–ª? –ò—Å–ø–æ–ª—å–∑—É–π: —Ü–≤–µ—Ç, —Ñ–æ—Ä–º—É, –º–∞—Ç–µ—Ä–∏–∞–ª, —ç–º–æ—Ü–∏—é –∏–ª–∏ <b>AI-–ø–æ–¥—Å–∫–∞–∑–∫—É</b>.</span>
                </li>
            </ul>
            <div class="mt-4 p-3 bg-gray-50 rounded-lg text-xs">
                <p><b>–ü—Ä–∏–º–µ—Ä (–°—Ç–æ–ª):</b> <span class="text-green-600">–î–µ—Ä–µ–≤—è–Ω–Ω—ã–π, —Ç–≤—ë—Ä–¥—ã–π, –ø–∏—Å—å–º–µ–Ω–Ω—ã–π...</span></p>
                <p class="mt-1"><span class="text-red-500">–ù–µ–ª—å–∑—è:</span> –°—Ç–æ–∏—Ç, –º–µ–±–µ–ª—å, –∑–∞ –Ω–∏–º –µ–¥—è—Ç...</p>
            </div>
            
            <label class="flex items-center mt-4 cursor-pointer">
                <input type="checkbox" id="rules-accepted" class="w-5 h-5 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                <span class="ml-2 text-sm font-medium">–ü—Ä–∞–≤–∏–ª–∞ –ø–æ–Ω—è—Ç–Ω—ã</span>
            </label>
        </div>

        <!-- Settings -->
        <div class="card p-5 mb-20 flex-grow">
            <h2 class="font-bold text-lg mb-4">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
            
            <!-- Time per word -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">–í—Ä–µ–º—è –Ω–∞ —Å–ª–æ–≤–æ (—Å–µ–∫)</label>
                <div class="grid grid-cols-4 gap-2">
                    <button class="setting-btn-time p-2 text-sm border rounded hover:bg-indigo-50" data-value="15">15</button>
                    <button class="setting-btn-time p-2 text-sm border rounded hover:bg-indigo-50" data-value="30">30</button>
                    <button class="setting-btn-time p-2 text-sm border rounded hover:bg-indigo-50" data-value="45">45</button>
                    <button class="setting-btn-time p-2 text-sm border rounded hover:bg-indigo-50" data-value="60">60</button>
                </div>
            </div>

            <!-- Total Time -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–º–∏–Ω)</label>
                <select id="total-time-select" class="w-full p-2 border rounded bg-white">
                    <option value="1">1 –º–∏–Ω—É—Ç–∞</option>
                    <option value="2">2 –º–∏–Ω—É—Ç—ã</option>
                    <option value="3">3 –º–∏–Ω—É—Ç—ã</option>
                    <option value="5">5 –º–∏–Ω—É—Ç</option>
                    <option value="10">10 –º–∏–Ω—É—Ç</option>
                    <option value="0">–ë–µ–∑–ª–∏–º–∏—Ç (–ø–æ–∫–∞ –Ω–µ –æ—Å—Ç–∞–Ω–æ–≤–ª—é)</option>
                </select>
            </div>

            <!-- Category -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">–ò—Å—Ç–æ—á–Ω–∏–∫ —Å–ª–æ–≤</label>
                <select id="category-select" class="w-full p-2 border rounded bg-white">
                    <option value="all">–í—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (–°–ª—É—á–∞–π–Ω–æ)</option>
                    <option value="objects">–ü—Ä–µ–¥–º–µ—Ç—ã (–ú–∞—Ç–µ—Ä–∏–∞–ª—å–Ω–æ–µ)</option>
                    <option value="abstract">–ê–±—Å—Ç—Ä–∞–∫—Ç–Ω–æ–µ (–ß—É–≤—Å—Ç–≤–∞, –∏–¥–µ–∏)</option>
                    <option value="characters">–ü–µ—Ä—Å–æ–Ω–∞–∂–∏ –∏ –ü—Ä–æ—Ñ–µ—Å—Å–∏–∏</option>
                    <option value="ai_gen">‚ú® –ò–ò-–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä (–õ—é–±–∞—è —Ç–µ–º–∞)</option>
                    <option value="custom">–°–≤–æ–π —Å–ø–∏—Å–æ–∫...</option>
                </select>
            </div>

             <!-- AI Generator Area (Hidden by default) -->
             <div id="ai-generator-area" class="mb-4 hidden p-3 bg-indigo-50 rounded-lg border border-indigo-100">
                <label class="block text-sm font-bold text-indigo-700 mb-1">–¢–µ–º–∞ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ ‚ú®</label>
                <div class="flex gap-2">
                    <input type="text" id="ai-topic-input" class="w-full p-2 border rounded text-sm" placeholder="–ù–∞–ø—Ä: –ì–∞—Ä—Ä–∏ –ü–æ—Ç—Ç–µ—Ä, –ö–æ—Å–º–æ—Å, –ï–¥–∞...">
                    <button id="btn-generate-ai" class="bg-indigo-600 text-white px-3 py-2 rounded text-sm font-medium whitespace-nowrap flex items-center gap-1">
                        <span id="ai-gen-icon">‚ú®</span>
                        <div id="ai-gen-loader" class="loader hidden"></div>
                        –°–æ–∑–¥–∞—Ç—å
                    </button>
                </div>
                <p id="ai-status-text" class="text-xs text-gray-500 mt-1 pl-1"></p>
            </div>

             <!-- Custom Words Area (Hidden by default) -->
             <div id="custom-words-area" class="mb-4 hidden">
                <label class="block text-sm font-medium text-gray-700 mb-1">–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–∞ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)</label>
                <textarea id="custom-words-input" class="w-full p-2 border rounded text-sm h-24" placeholder="–Ø–±–ª–æ–∫–æ, –†–∞–¥–æ—Å—Ç—å, –ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç..."></textarea>
            </div>

            <!-- Mode & Sound -->
            <div class="flex justify-between items-center mb-2">
                <span class="text-sm">–ê–≤—Ç–æ-–ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å–ª–æ–≤</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="auto-mode-toggle" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                </label>
            </div>
            <div class="flex justify-between items-center">
                <span class="text-sm">–ó–≤—É–∫–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="sound-toggle" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                </label>
            </div>
        </div>

        <!-- Start Button Wrapper (Fixed at bottom) -->
        <div class="fixed bottom-0 left-0 right-0 p-4 bg-white border-t md:relative md:border-none md:bg-transparent md:p-0">
            <button id="btn-start" class="btn w-full bg-indigo-600 text-white font-bold py-4 rounded-xl text-lg shadow-lg disabled:opacity-50 disabled:cursor-not-allowed">
                –ù–ê–ß–ê–¢–¨ –¢–†–ï–ù–ò–†–û–í–ö–£
            </button>
        </div>
    </div>

    <!-- 2. GAME SCREEN -->
    <div id="screen-game" class="screen bg-white h-screen relative">
        <!-- Top Bar -->
        <div class="flex justify-between items-center p-4 border-b">
            <div class="text-sm font-mono text-gray-500" id="session-progress">–°–ª–æ–≤–æ 1 / --</div>
            <div class="text-sm font-bold text-red-500" id="total-timer-display">00:00</div>
        </div>

        <!-- Main Content -->
        <div class="flex-grow flex flex-col justify-center items-center p-6 text-center relative w-full">
            <div class="mb-8 w-full max-w-sm">
                <div class="flex justify-between text-xs text-gray-400 mb-1">
                    <span>–¢–∞–π–º–µ—Ä —Å–ª–æ–≤–∞</span>
                    <span id="word-timer-text">30—Å</span>
                </div>
                <div class="timer-bar-container">
                    <div id="word-timer-bar" class="timer-bar"></div>
                </div>
            </div>

            <div id="word-display" class="text-4xl md:text-5xl font-bold text-gray-800 mb-4 break-words w-full word-anim">
                –ó–∞–≥—Ä—É–∑–∫–∞...
            </div>
            
            <p class="text-gray-400 text-sm italic mt-2">–û—Ç–≤–µ—á–∞–π –≤—Å–ª—É—Ö: ¬´–ö–∞–∫–æ–π?¬ª</p>

            <!-- AI Hint Section -->
            <div class="mt-8 w-full max-w-xs min-h-[60px] flex flex-col items-center justify-center">
                 <button id="btn-hint" class="text-indigo-600 text-sm font-medium bg-indigo-50 px-4 py-2 rounded-full hover:bg-indigo-100 flex items-center gap-2 transition-colors">
                    <span>‚ú® –ü–æ–¥—Å–∫–∞–∑–∫–∞</span>
                    <div id="hint-loader" class="loader hidden w-4 h-4 border-2 border-t-indigo-600"></div>
                 </button>
                 <div id="hint-text" class="text-sm text-gray-600 mt-2 font-medium hidden text-center animate-fade-in">
                    <!-- Hint text will appear here -->
                 </div>
            </div>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-overlay" class="absolute inset-0 bg-white/95 z-50 flex flex-col items-center justify-center hidden">
            <h2 class="text-3xl font-bold text-gray-800 mb-8">–ü–ê–£–ó–ê</h2>
            <button id="btn-resume" class="btn bg-indigo-600 text-white px-8 py-3 rounded-full text-lg mb-4 shadow-lg">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
            <button id="btn-stop-early" class="btn text-red-500 font-medium p-4">–ó–∞–≤–µ—Ä—à–∏—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É</button>
        </div>

        <!-- Controls -->
        <div class="p-4 pb-8 bg-gray-50 border-t">
            <div class="max-w-md mx-auto grid grid-cols-3 gap-4">
                <button id="btn-pause" class="btn bg-white border border-gray-300 text-gray-700 py-4 rounded-xl font-medium shadow-sm">
                    ‚è∏ –ü–∞—É–∑–∞
                </button>
                <button id="btn-next" class="btn col-span-2 bg-indigo-600 text-white py-4 rounded-xl font-bold text-lg shadow-md flex items-center justify-center">
                    –î–∞–ª—å—à–µ <span class="ml-2">‚Üí</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 3. RESULT SCREEN -->
    <div id="screen-result" class="screen p-4 max-w-md mx-auto justify-center">
        <div class="card p-8 text-center mb-6">
            <div class="w-16 h-16 bg-green-100 text-green-600 rounded-full flex items-center justify-center mx-auto mb-4 text-3xl">
                üèÅ
            </div>
            <h2 class="text-2xl font-bold text-gray-800 mb-2">–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</h2>
            <p class="text-gray-500 mb-6">–û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞ –Ω–∞–¥ —Ä–µ—á—å—é.</p>

            <div class="grid grid-cols-2 gap-4 mb-6">
                <div class="p-3 bg-gray-50 rounded-lg">
                    <div class="text-xs text-gray-400 uppercase">–í—Ä–µ–º—è</div>
                    <div class="text-xl font-bold text-indigo-600" id="result-time">05:00</div>
                </div>
                <div class="p-3 bg-gray-50 rounded-lg">
                    <div class="text-xs text-gray-400 uppercase">–°–ª–æ–≤</div>
                    <div class="text-xl font-bold text-indigo-600" id="result-count">15</div>
                </div>
            </div>

            <div class="text-left text-sm text-gray-500 bg-gray-50 p-3 rounded mb-2">
                <span class="block">üìö –ö–∞—Ç–µ–≥–æ—Ä–∏—è: <span id="result-category" class="font-medium text-gray-700">–í—Å–µ</span></span>
                <span class="block mt-1">‚è± –ù–∞ —Å–ª–æ–≤–æ: <span id="result-word-time" class="font-medium text-gray-700">30 —Å–µ–∫</span></span>
            </div>
        </div>

        <button id="btn-restart" class="btn w-full bg-indigo-600 text-white font-bold py-3 rounded-xl shadow-lg mb-3">
            –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ
        </button>
        <button id="btn-home" class="btn w-full bg-white border border-gray-300 text-gray-700 font-medium py-3 rounded-xl shadow-sm">
            –í –º–µ–Ω—é
        </button>
    </div>

    <script>
        const apiKey = ""; // System will inject the key

        // --- DATA & DICTIONARIES ---
        const defaultDictionaries = {
            objects: [
                "–°—Ç–æ–ª", "–¢–µ–ª–µ—Ñ–æ–Ω", "–Ø–±–ª–æ–∫–æ", "–ö–∏—Ä–ø–∏—á", "–ü–æ–¥—É—à–∫–∞", "–í–æ–¥–∞", "–ó–µ—Ä–∫–∞–ª–æ", "–ö–ª—é—á", 
                "–î–µ—Ä–µ–≤–æ", "–ö–Ω–∏–≥–∞", "–ë–æ—Ç–∏–Ω–æ–∫", "–ö–æ–ª–µ—Å–æ", "–õ–∞–º–ø–∞", "–ù–æ–∂", "–°–Ω–µ–≥", "–ü–µ—Å–æ–∫",
                "–ö–æ—Ç", "–ü–æ–ª–æ—Ç–µ–Ω—Ü–µ", "–ú–æ–Ω–µ—Ç–∞", "–ß–µ–º–æ–¥–∞–Ω", "–û–∫–Ω–æ", "–ú—ã–ª–æ", "–ì–∏—Ç–∞—Ä–∞", "–ß–∞—Å—ã"
            ],
            abstract: [
                "–†–∞–¥–æ—Å—Ç—å", "–í—Ä–µ–º—è", "–°–≤–æ–±–æ–¥–∞", "–î—Ä—É–∂–±–∞", "–£—Å–ø–µ—Ö", "–¢–∏—à–∏–Ω–∞", "–•–∞–æ—Å", "–õ—é–±–æ–≤—å",
                "–°—Ç—Ä–∞—Ö", "–ò–¥–µ—è", "–ú—É–∑—ã–∫–∞", "–°–æ–Ω", "–ë—É–¥—É—â–µ–µ", "–¢–∞–ª–∞–Ω—Ç", "–ß–µ—Å—Ç—å", "–û–¥–∏–Ω–æ—á–µ—Å—Ç–≤–æ",
                "–ü—Ä–∞–≤–¥–∞", "–†–∏—Å–∫", "–£—é—Ç", "–≠–Ω–µ—Ä–≥–∏—è", "–ì—Ä—É—Å—Ç—å", "–ú—ã—Å–ª—å", "–í–µ—Ç–µ—Ä"
            ],
            characters: [
                "–í—Ä–∞—á", "–ö–ª–æ—É–Ω", "–£—á–∏—Ç–µ–ª—å", "–ü–∏—Ä–∞—Ç", "–†–æ–±–æ—Ç", "–†–µ–±—ë–Ω–æ–∫", "–ë–∞–±—É—à–∫–∞", "–ö–æ—Ä–æ–ª—å",
                "–®–ø–∏–æ–Ω", "–ü–æ–≤–∞—Ä", "–•—É–¥–æ–∂–Ω–∏–∫", "–°–æ–ª–¥–∞—Ç", "–í–æ–¥–∏—Ç–µ–ª—å", "–ü—Ä–∏–∑—Ä–∞–∫", "–°—É–ø–µ—Ä–≥–µ—Ä–æ–π",
                "–î–µ—Ç–µ–∫—Ç–∏–≤", "–§–µ—Ä–º–µ—Ä", "–°—Ç—É–¥–µ–Ω—Ç", "–ö–æ—Å–º–æ–Ω–∞–≤—Ç", "–í–∞–º–ø–∏—Ä"
            ]
        };

        // --- APP STATE ---
        const state = {
            settings: {
                timePerWord: 30,
                totalTimeMinutes: 3,
                category: 'all',
                autoSwitch: true,
                soundEnabled: true,
                customWords: [],
                aiWords: [], // Store generated words here
                lastAiTopic: ""
            },
            session: {
                isActive: false,
                isPaused: false,
                startTime: 0,
                totalElapsed: 0,
                wordsShown: 0,
                currentWord: "",
                wordStartTime: 0,
                timerInterval: null,
                wordsQueue: [],
                totalTimeLimitMs: 0
            }
        };

        // --- AUDIO HELPERS ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (!state.settings.soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'tick') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.05);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.05);
            } else if (type === 'switch') {
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'end') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
                oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.6);
            }
        }

        // --- GEMINI API HELPERS ---
        async function callGemini(prompt) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }]
            };
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
            } catch (error) {
                console.error("Gemini API Error:", error);
                return null;
            }
        }

        async function generateAiWords(topic) {
            const prompt = `Generate a JSON array of 25 distinct Russian nouns (single words, no phrases) related to the topic: "${topic}". 
            The words should be concrete enough to describe with adjectives (e.g. if topic is Harry Potter, use 'Wand', 'Owl', not 'Magic'). 
            Output ONLY the raw JSON array, no markdown code blocks, no other text.`;
            
            try {
                const text = await callGemini(prompt);
                if (!text) throw new Error("No response");
                
                // Clean markdown if present
                const jsonStr = text.replace(/```json|```/g, '').trim();
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error("Parsing error", e);
                return ["–û—à–∏–±–∫–∞ AI", "–ü–æ–ø—Ä–æ–±—É–π", "–°–Ω–æ–≤–∞"];
            }
        }

        async function getAiHint(word) {
            const prompt = `Give me 3 short Russian adjectives to describe the word "${word}" WITHOUT naming the word itself or using same-root words. 
            Format: "Adj1, Adj2, Adj3". Keep it simple.`;
            
            const text = await callGemini(prompt);
            return text ? text.trim() : "–ù–µ –º–æ–≥—É –ø—Ä–∏–¥—É–º–∞—Ç—å...";
        }

        // --- DOM ELEMENTS ---
        const screens = {
            rules: document.getElementById('screen-rules'),
            game: document.getElementById('screen-game'),
            result: document.getElementById('screen-result')
        };
        const els = {
            startBtn: document.getElementById('btn-start'),
            rulesCheck: document.getElementById('rules-accepted'),
            timeBtns: document.querySelectorAll('.setting-btn-time'),
            totalTimeSelect: document.getElementById('total-time-select'),
            categorySelect: document.getElementById('category-select'),
            
            // Custom & AI Areas
            customWordsArea: document.getElementById('custom-words-area'),
            customWordsInput: document.getElementById('custom-words-input'),
            aiGeneratorArea: document.getElementById('ai-generator-area'),
            aiTopicInput: document.getElementById('ai-topic-input'),
            btnGenerateAi: document.getElementById('btn-generate-ai'),
            aiStatusText: document.getElementById('ai-status-text'),
            aiGenLoader: document.getElementById('ai-gen-loader'),
            aiGenIcon: document.getElementById('ai-gen-icon'),

            autoModeToggle: document.getElementById('auto-mode-toggle'),
            soundToggle: document.getElementById('sound-toggle'),
            
            // Game elements
            wordDisplay: document.getElementById('word-display'),
            wordTimerBar: document.getElementById('word-timer-bar'),
            wordTimerText: document.getElementById('word-timer-text'),
            totalTimerDisplay: document.getElementById('total-timer-display'),
            sessionProgress: document.getElementById('session-progress'),
            pauseOverlay: document.getElementById('pause-overlay'),
            btnPause: document.getElementById('btn-pause'),
            btnResume: document.getElementById('btn-resume'),
            btnNext: document.getElementById('btn-next'),
            btnStopEarly: document.getElementById('btn-stop-early'),
            
            // Hint elements
            btnHint: document.getElementById('btn-hint'),
            hintText: document.getElementById('hint-text'),
            hintLoader: document.getElementById('hint-loader'),

            // Result elements
            resTime: document.getElementById('result-time'),
            resCount: document.getElementById('result-count'),
            resCat: document.getElementById('result-category'),
            resWTime: document.getElementById('result-word-time'),
            btnRestart: document.getElementById('btn-restart'),
            btnHome: document.getElementById('btn-home'),

            // Welcome
            welcomeText: document.getElementById('welcome-text')
        };

        // --- INIT ---
        function init() {
            // Telegram Mini App Initialization
            if (window.Telegram && window.Telegram.WebApp) {
                const tg = window.Telegram.WebApp;
                tg.ready();
                tg.expand();

                // Personalization if user info is available
                if (tg.initDataUnsafe && tg.initDataUnsafe.user) {
                    const firstName = tg.initDataUnsafe.user.first_name;
                    if (els.welcomeText) {
                        els.welcomeText.innerText = `–ü—Ä–∏–≤–µ—Ç, ${firstName}! –ì–æ—Ç–æ–≤ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è?`;
                    }
                }
            }

            loadSettings();
            setupListeners();
            checkRulesStatus();
            updateTimeSelectionUI();
        }

        // --- LOCAL STORAGE & SETTINGS ---
        function loadSettings() {
            const saved = localStorage.getItem('wt_settings');
            if (saved) {
                const parsed = JSON.parse(saved);
                state.settings = { ...state.settings, ...parsed };
                
                // Restore UI states
                els.totalTimeSelect.value = state.settings.totalTimeMinutes;
                els.categorySelect.value = state.settings.category;
                els.autoModeToggle.checked = state.settings.autoSwitch;
                els.soundToggle.checked = state.settings.soundEnabled;
                
                updateCategoryUI(state.settings.category);
                
                if(state.settings.customWords) els.customWordsInput.value = state.settings.customWords.join(', ');
                if(state.settings.lastAiTopic) els.aiTopicInput.value = state.settings.lastAiTopic;
            }
        }

        function saveSettings() {
            localStorage.setItem('wt_settings', JSON.stringify(state.settings));
        }

        function updateCategoryUI(category) {
            els.customWordsArea.classList.add('hidden');
            els.aiGeneratorArea.classList.add('hidden');
            
            if (category === 'custom') {
                els.customWordsArea.classList.remove('hidden');
            } else if (category === 'ai_gen') {
                els.aiGeneratorArea.classList.remove('hidden');
            }
        }

        // --- LISTENERS ---
        function setupListeners() {
            // Rules checkbox
            els.rulesCheck.addEventListener('change', checkRulesStatus);

            // Time per word buttons
            els.timeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    state.settings.timePerWord = parseInt(btn.dataset.value);
                    updateTimeSelectionUI();
                    saveSettings();
                });
            });

            // Dropdowns
            els.totalTimeSelect.addEventListener('change', (e) => {
                state.settings.totalTimeMinutes = parseInt(e.target.value);
                saveSettings();
            });

            els.categorySelect.addEventListener('change', (e) => {
                state.settings.category = e.target.value;
                updateCategoryUI(e.target.value);
                saveSettings();
            });

            els.customWordsInput.addEventListener('change', (e) => {
                const text = e.target.value;
                state.settings.customWords = text.split(',').map(s => s.trim()).filter(s => s.length > 0);
                saveSettings();
            });

            // AI Generation Button
            els.btnGenerateAi.addEventListener('click', async () => {
                const topic = els.aiTopicInput.value.trim();
                if (!topic) return;
                
                // UI Loading State
                els.btnGenerateAi.disabled = true;
                els.aiGenIcon.classList.add('hidden');
                els.aiGenLoader.classList.remove('hidden');
                els.aiStatusText.innerText = "–ì–µ–Ω–µ—Ä–∏—Ä—É—é —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤...";
                els.aiStatusText.className = "text-xs text-indigo-500 mt-1 pl-1";

                const words = await generateAiWords(topic);
                
                // UI Finished State
                els.btnGenerateAi.disabled = false;
                els.aiGenIcon.classList.remove('hidden');
                els.aiGenLoader.classList.add('hidden');
                
                if (words && words.length > 0) {
                    state.settings.aiWords = words;
                    state.settings.lastAiTopic = topic;
                    saveSettings();
                    els.aiStatusText.innerText = `–ì–æ—Ç–æ–≤–æ! ${words.length} —Å–ª–æ–≤ –ø–æ —Ç–µ–º–µ "${topic}".`;
                    els.aiStatusText.className = "text-xs text-green-600 mt-1 pl-1 font-medium";
                } else {
                    els.aiStatusText.innerText = "–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥—É—é —Ç–µ–º—É.";
                    els.aiStatusText.className = "text-xs text-red-500 mt-1 pl-1";
                }
            });

            // Toggles
            els.autoModeToggle.addEventListener('change', (e) => {
                state.settings.autoSwitch = e.target.checked;
                saveSettings();
            });
            els.soundToggle.addEventListener('change', (e) => {
                state.settings.soundEnabled = e.target.checked;
                saveSettings();
            });

            // Navigation
            els.startBtn.addEventListener('click', startSession);
            els.btnPause.addEventListener('click', pauseGame);
            els.btnResume.addEventListener('click', resumeGame);
            els.btnStopEarly.addEventListener('click', finishSession);
            els.btnNext.addEventListener('click', nextWord);
            els.btnRestart.addEventListener('click', () => { showScreen('game'); startSession(); });
            els.btnHome.addEventListener('click', () => showScreen('rules'));
            
            // Hint
            els.btnHint.addEventListener('click', async () => {
                const word = state.session.currentWord;
                if (!word || els.hintText.innerText !== "") return; // Prevent double click or empty
                
                els.btnHint.disabled = true;
                els.hintLoader.classList.remove('hidden');
                
                const hint = await getAiHint(word);
                
                els.hintLoader.classList.add('hidden');
                els.hintText.innerText = hint;
                els.hintText.classList.remove('hidden');
                els.btnHint.classList.add('hidden'); // Hide button after use for this word
            });
        }

        function checkRulesStatus() {
            if (els.rulesCheck.checked) {
                els.startBtn.disabled = false;
                els.startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                els.startBtn.disabled = true;
                els.startBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        function updateTimeSelectionUI() {
            els.timeBtns.forEach(btn => {
                const val = parseInt(btn.dataset.value);
                if (val === state.settings.timePerWord) {
                    btn.classList.add('bg-indigo-600', 'text-white', 'border-indigo-600');
                    btn.classList.remove('border-gray-300', 'text-gray-700');
                } else {
                    btn.classList.remove('bg-indigo-600', 'text-white', 'border-indigo-600');
                    btn.classList.add('border-gray-300', 'text-gray-700');
                }
            });
        }

        function showScreen(screenName) {
            Object.values(screens).forEach(el => el.classList.remove('active'));
            screens[screenName].classList.add('active');
        }

        // --- GAME LOGIC ---

        function generateQueue() {
            let pool = [];
            const cat = state.settings.category;

            if (cat === 'all') {
                pool = [...defaultDictionaries.objects, ...defaultDictionaries.abstract, ...defaultDictionaries.characters];
            } else if (cat === 'custom') {
                pool = state.settings.customWords.length > 0 ? state.settings.customWords : ["–ù–µ—Ç —Å–ª–æ–≤ (–Ω–∞—Å—Ç—Ä–æ–π —Å–ø–∏—Å–æ–∫)"];
            } else if (cat === 'ai_gen') {
                 pool = state.settings.aiWords.length > 0 ? state.settings.aiWords : ["–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —Å–ª–æ–≤–∞ —Å–Ω–∞—á–∞–ª–∞!"];
            } else {
                pool = defaultDictionaries[cat] || [];
            }
            // Shuffle
            return pool.sort(() => Math.random() - 0.5);
        }

        function startSession() {
            if(audioCtx.state === 'suspended') audioCtx.resume();

            state.session.wordsQueue = generateQueue();
            state.session.wordsShown = 0;
            state.session.startTime = Date.now();
            state.session.totalElapsed = 0; // ms
            state.session.isActive = true;
            state.session.isPaused = false;
            
            // Calc total limit
            state.session.totalTimeLimitMs = state.settings.totalTimeMinutes * 60 * 1000;

            showScreen('game');
            els.pauseOverlay.classList.add('hidden');
            
            // Start Loop
            nextWord();
            state.session.timerInterval = requestAnimationFrame(gameLoop);
        }

        function nextWord() {
            if (!state.session.isActive) return;

            // Check if queue empty -> reshuffle
            if (state.session.wordsQueue.length === 0) {
                 state.session.wordsQueue = generateQueue();
            }

            state.session.currentWord = state.session.wordsQueue.pop();
            state.session.wordStartTime = Date.now(); // Reset word timer
            state.session.wordsShown++;

            // Reset UI for new word
            els.wordDisplay.classList.remove('word-anim');
            void els.wordDisplay.offsetWidth; // Trigger reflow
            els.wordDisplay.classList.add('word-anim');
            
            els.wordDisplay.innerText = state.session.currentWord;
            els.sessionProgress.innerText = `–°–ª–æ–≤–æ ${state.session.wordsShown}`;
            
            // Reset Hint UI
            els.hintText.innerText = "";
            els.hintText.classList.add('hidden');
            els.btnHint.classList.remove('hidden');
            els.btnHint.disabled = false;
            
            playSound('switch');
        }

        function pauseGame() {
            state.session.isPaused = true;
            els.pauseOverlay.classList.remove('hidden');
        }

        function resumeGame() {
            state.session.isPaused = false;
            els.pauseOverlay.classList.add('hidden');
        }

        let lastTime = Date.now();

        function gameLoop() {
            if (!state.session.isActive) return;

            const now = Date.now();
            const delta = now - lastTime;
            lastTime = now;

            if (state.session.isPaused) {
                // Shift timestamps forward so time stands still
                state.session.startTime += delta;
                state.session.wordStartTime += delta;
                state.session.timerInterval = requestAnimationFrame(gameLoop);
                return;
            }

            // 1. Total Time Logic
            const totalElapsed = now - state.session.startTime;
            if (state.settings.totalTimeMinutes > 0) {
                const totalRemaining = state.session.totalTimeLimitMs - totalElapsed;
                if (totalRemaining <= 0) {
                    finishSession();
                    return;
                }
                els.totalTimerDisplay.innerText = formatTime(totalRemaining);
            } else {
                els.totalTimerDisplay.innerText = formatTime(totalElapsed);
            }

            // 2. Word Timer Logic
            const wordElapsed = now - state.session.wordStartTime;
            const wordLimitMs = state.settings.timePerWord * 1000;
            const wordRemaining = wordLimitMs - wordElapsed;

            const pct = Math.max(0, (wordRemaining / wordLimitMs) * 100);
            els.wordTimerBar.style.width = `${pct}%`;
            els.wordTimerText.innerText = `${Math.ceil(wordRemaining / 1000)}—Å`;

            if (wordRemaining < 5000) els.wordTimerBar.classList.add('urgent');
            else els.wordTimerBar.classList.remove('urgent');

            // 3. Auto Switch
            if (wordRemaining <= 0) {
                if (state.settings.autoSwitch) {
                    nextWord();
                } else {
                    // In manual mode, timer stays at 0
                    els.wordTimerBar.style.width = '0%';
                    els.wordTimerText.innerText = '0—Å';
                }
            } 

            state.session.timerInterval = requestAnimationFrame(gameLoop);
        }

        function finishSession() {
            state.session.isActive = false;
            cancelAnimationFrame(state.session.timerInterval);
            playSound('end');

            const now = Date.now();
            const totalMs = now - state.session.startTime;

            // Fill Result Screen
            els.resTime.innerText = formatTime(totalMs);
            els.resCount.innerText = state.session.wordsShown;
            
            const cats = {
                'all': '–í—Å–µ', 'objects': '–ü—Ä–µ–¥–º–µ—Ç—ã', 'abstract': '–ê–±—Å—Ç—Ä–∞–∫—Ç–Ω–æ–µ', 
                'characters': '–ü–µ—Ä—Å–æ–Ω–∞–∂–∏', 'custom': '–°–≤–æ–∏', 'ai_gen': '–ò–ò –¢–µ–º–∞ ‚ú®'
            };
            els.resCat.innerText = cats[state.settings.category] || state.settings.category;
            els.resWTime.innerText = `${state.settings.timePerWord} —Å–µ–∫`;

            showScreen('result');
        }

        // Helper
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const m = Math.floor(totalSeconds / 60);
            const s = totalSeconds % 60;
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Run Init
        init();

    </script>
</body>
</html>
